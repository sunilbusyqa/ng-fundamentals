Angular Pre-requisites:

1. GIT
2. NVM - Node Version Manager - Helps manage version of node.js

	Windows: Download nvm-setup.zip from https://github.com/coreybutler/nvm-windows/releases/tag/1.1.6
	Mac/Linux: Run command -> curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.0/install.sh | bash

3. Open GIT Bash as Administrator
   Install Node v8.11.2

	1. nvm install v8.11.2
	2. nvm use 8.11.2

If there is a problem installing node, try installing from https://nodejs.org/download/release/v8.11.2/

Create a dev folder under C. Run the following commands

	Windows -> mkdir C:/dev AND cd c:/dev
	Mac/Linux -> md /Users/<user>/dev AND cd /Users/<user>/dev

4. Angular CLI
	
	Best way to start creating Angular project is to use Angular CLI. It is a command line interface to create a new project complete with webpack config and tools for packaging up your app for production, plus a host of other features. It is highly recommended that you always start your projects with the CLI

	npm install -g @angular/cli@7.1.2

	This will install angular cli globally to allow us create multiple projects.

5. Create new project

	ng new ng-fundamentals

6. IDE for development. Preferred are Visual Studio Code OR IntelliJ IDEA

	Visual Studio Code: Download from https://code.visualstudio.com/
	IntelliJ IDEA: Download from https://www.jetbrains.com/idea/download/download-thanks.html?platform=windows&code=IIC

7. Open the project in the IDE and start coding!


angular.json - configuring properties for the project
e2e - for testing
node_modules - dependent jars
src - where code and resources reside

src/app - application code
src/assets - static resources like images

package.json - defines the dependencies. Download the file from https://github.com/sunilbusyqa/ng-fundamentals/blob/master/package.json and replace the existing file content.

package-lock.json - Download the file from https://github.com/sunilbusyqa/ng-fundamentals/blob/master/package-lock.json and replace the existing file content.

Now, go back to GIT bash console and delete the node_modules and re-install them. Run the following commands:

	cd ng-fundamentals
	rm -rf node_modules
	npm install

Now our package versions are locked-in. This will help us work in consistency without any suprises in between due to version updates.

8. Now, it's time to run the project

	npm start

	This should start your application on 4200. Now, open the URL http://localhost:4200 and you should see a full functioning frontend application.


Component contains -> component ts file, html file and css file

Bootstraping flow:

	In angular.json, property "main" refers to "src/main.ts". Angular webpack loads the main.ts file.
	In main.ts file, you can see "bootstrapModule(AppModule)" which lets angular know that there is a module named AppModule that it needs to load
	In app.module.ts, you can see "bootstrap: [AppComponent]" which tells angular that there is component that it needs to load.
	In app.component.ts, it has "selector: 'app-root'". this defines the html tag "<app-root>" that can be used to load the template (html file) that is defined as "templateUrl: './app.component.html'".
	In index.html, you can see "<app-root></app-root>". Angular knows the component has the selector with this name and loads the template in the component.

	So the content that was displayed is the content from app.component.html


Convert the current application to Events app - refer to https://www.github.com/sunilbusyqa/ng-fundamentals

Structure of Modules:

1. declarations -> components are declared here
2. imports -> imports other modules. ex: BrowserModule
3. providers -> services
4. bootstrap -> initial loading components

Static resources:

Download sample image files from https://www.github.com/sunilbusyqa/ng-fundamentals into assets folder in the current project.

If you load image in html, you give the location as relative location

Ex: <img src="/assets/images/basic-shield.png"/>

How does angular know this location?

	angular.json file has a property named "assets" which holds all the locations of assets. This helps angular identify the assets we use in our project.

Similarly, there are other properties

	"styles" -> indicate CSS files. Default is "src/styles.css" file
	"scripts" that indicate the Javascript files we need. For ex: bootstrap js, jquery etc...

Styling:

	Copy the CSS content from https://www.github.com/sunilbusyqa/ng-fundamentals/blob/master/src/styles.css
	and paste them in your project src/styles.css file

	Bootstrap is a famous CSS library that we can use to leverage the designs. An author named Jim Cooper created a bootstrap node module we can install and use within our project.

	Go to GIT Bash and run the following command:

	npm install ngf-bootstrap --save

	This module downloads the bootstrap css, js files and jquery. We can also download them individually and place them in a folder and use them. The module approach is convenient.

	cd node_modules

	You should find ngf-boostrap, bootstrap and jquery folders

	cd ..
	npm start

	To use the bootstrap CSS, go to angular.json file and update "styles" and "scripts" as follows

	"styles": [
		"node_modules/ngf-bootstrap/dist/bootstrap.min.css",
		"src/styles.css"
	],
	"scripts": [
		"node_modules/jquery/dist/jquery.min.js",
		"node_modules/bootstrap/dist/js/bootstrap.js"
	]

	Now restart the server

	Ctrl + C
	npm start

	You will see the page is displayed differently.

canActivate, canDeactiavte

Module 3:

Let's learn the following:

1. Route guards. Let's create 404 page if a page does not exist
2. Route for user. Creating user module and using it in app.module.ts
3. Demonstrating individual module loading using profile page
4. Different forms - Template based (login page) and reactive (profile page)
5. 


Resolve - pre checks and post checks after loading a component

routerLinkActive, routerLinkActiveOptions

Independent modules. Ex: User Profile module

Barrels to organize exports

Forms: Template based

	More logic in template. Difficult for complex forms, validations

Model based (reactive forms)

	More logic in component

Let's try Template based forms with login page
To use template based, we need FormsModule. Import that in your application module
One way to bind data from form is to use syntax like this

	<input (input)="userName=$event.target.value" ...>

This can be simplified by using ngModel

One way binding is defined as (ngModel)="userName"
Two way binding is defined as [(ngModel)]="userName". This is called banana box syntax

() are used to represent events, [] are used to represent data

By default, these are fields of the form and so to retrieve these fields, we need to identify the form
we can do as below

<form #loginForm="ngForm" (ngSubmit)="login(loginForm.value)" autocomplete="off" novalidate>

Here we are naming the form as loginForm and when we submit the form by clicking on save button, we are passing the values of the form to login method in component

Some of the properties you can leverage on a form are

loginForm.valid - all fields are validated
loginForm.invalid - validation failed
loginForm.dirty - some values are assigned to the form variables
loginForm.pristine - form is empty. not even touched. this is usually initial loading state
loginForm.submitted - form save button clicked
loginForm.touched - form field touched. even when it is not edited if it is accessed, it is touched
loginForm.untouched - form field not accessed yet on the page

Lets build a reactive form. this involves creating form in the component and passing it to template.
HTML page looks pretty similar but the form group is created in the component

Let's use profile page as our reactive form

We need to import ReactiveFormsModule in our app.module.ts
We create form fields as FormControl in component and FormGroup as the form

ex:

let firstName = new FormControl()
    let lastName = new FormControl()
    this.profileForm = new FormGroup({
      firstName: firstName,
      lastName: lastName
    })

To use this formGroup, we add it in the form on HTML page as follows

<form [formGroup]="profileForm" (ngSubmit)="saveProfile(profileForm.value)" autocomplete="off" novalidate>

and we use individual fields as formControlName as shown below

<input formControlName="firstName" id="firstName" type="text" class="form-control" placeholder="First Name..." />

To validate fields, we use Validators. We pass them as second argument in FormControl

ex:

	let firstName = new FormControl(this.authService.currentUser.firstName, Validators.required)
    let lastName = new FormControl(this.authService.currentUser.lastName, Validators.required)

We can more validators by passing an array of such validators to FormControl

ex:

	let firstName = new FormControl(this.authService.currentUser.firstName, [Validators.required, Validators.pattern('[a-zA-Z.*]')])

Here it is validating to make sure the field always starts with an alphabet
More validators can be found in angular.io docs -> search Validators

With small forms, template driven is preferrable. However, when more fields are added, reactive forms are useful especially for testing as we can mock the form


Let's work more on template driven form. Let's work on create event form



Content Projection: resuable code that can be used across components

Pipes

Communicating with the server using HTTP, Observables, and Rx:

	For this purpose, we use a simple node based server to provide us the required data that we are currently using as static data in our angular project.
	Install the already created sample server like this:

		npm install ngf-server -S
		
		This is going to add ngf-server to node_modules and also add that to our package.json dependencies.

	Now that we installed ngf-server, add a command to start it through our project.
	In package.json -> scripts, add the following:

		"server": "node node_modules/ngf-server/server.js"
	
	This now registers "server" as a command in our project that we can run. To run the server, run the following command

		npm server
	
	You can also choose to run it directly as well

	Next thing we need is to tell our angular project that we want it to use the server for all the endpoints that start with "/api"
	To do that we need to create a proxy configuration file in the root of our project.

	Go ahead and create a file named proxy.conf.json with following content:

		{
			"/api": {
				"target": "http://localhost:8808",
				"secure": false
			}
		}
	
	Here we are saying that for endpoints starting with "/api", it should call our server that's running on port 8808 and since it's a simple server is it not secure (no authentication)

	To let angular use this proxy, go to package.json, scripts and change the following:

		"start": "ng serve --proxy-config proxy.conf.json"
	
	This starts the angular server with proxy configuration

	To use HTTP, we need a new module named "HttpClientModule" from '@angular/common/http'. register that in app.module.js
	
	Following are HTTP methods we will use in this course: GET, POST, PUT, DELETE

	For implementation, check event.service.ts and auth.service.ts files

	Remember, the endpoints and returned data totally depend on how you designed your backend. For this course, the server created has following endpoints:

	/api/events
	/api/events/{id}

	/api/login
	/api/currentIdentity
	/api/users/{id}
	/api/logout


Testing Angular projects

	Karma
	Services
	Isolated Component Tests

	What is a Unit Test
		A test of a single "unit" of code.

	Unit Test vs End to End Test

	Unit Test:
		Fast
		Involve Isolated Pieces of Code

	End to End Test:
		Slow
		Exercises the Entire System

	We are only going to focus on Unit Test


	Attributes of good unit test

		Fast
		Cheap to Write
		Single State Change
		Assert 1 Thing
		Doesn't Cross Process Boundaries
		Reliable
	

	Unit Test Structure

	AAA
		Arrange - prepare code
		Act	- make a change
		Assert - test the change
	
	Example:
		Arrange:
			var user = new User("Sally)
			user.friends = ["Ralph"]
		
		Act:
			user.addFriend("John")

		Assert:
			expect(user.friends.length).toBe(2)

	Mocking
		Helps mock the object when construction is difficult or not possible

		Speed
		Ease of Testing

		Example if you need to make http call in unit test which we shouldn't, we replace http with it's mock
	
	
	Jamine is the unit testing library

		describe()
		beforeEach()
		it()
		expect()
		Matchers
			toBe()
			toContain()
			toBeDefined()
	
	Karma is command line test runner

		Runs tests in Browser
		Multiple Browsers
		Reports
	
		In our code, npm test triggers karma and runs the test. By default, no tests are present
		Default web url to see result is http://localhost:9878

		Karma looks for test.spec.ts under app in our project

		create test.spec.ts and add following code

		describe('testing true', () => {
			it('should be true', () => {
				expect(true).toBe(true)
			})
		})

		karma should pick the test and show it's a success

	Isolated vs Integrated Tests

	Isolated:
		Test Class Only - No Template
		Constructed in Test
		Simple
		Best for Services & Pipes
		Appropriate for Components & Directives
	
	Integrated Tests
		Test Class & Template
		Constructed by Framework
		Complex
		Mainly Used for Components & Directives
		Deep (multiple levels) or Shallow (one level)

	We created unit test with mock in auth.service.spec.ts file. check it out

